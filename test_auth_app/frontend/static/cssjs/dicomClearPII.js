var PIItagsEmpty = {
	"x00020100":	"Private Information Creator UID",
	"x00020102":	"Private Information",
	"x00100010":	"Patient's Name",
	"x00100020":	"Patient ID",
	"x00100021":	"Issuer of Patient ID",
	"x00100022":	"Type of Patient ID",
	"x00100030":	"Patient's Birth Date", 
	"x00100032":	"Patient's Birth Time",
	"x00100040":    "Patient's Sex",
	"x00100050":	"Patient's Insurance Plan Code Sequence", 
	"x00100101":	"Patient's Primary Language Code Sequence", 
	"x00100102":	"Patient's Primary Language Code Modifier Sequence",
	"x00101000":	"Other Patient IDs", 
	"x00101001":	"Other Patient Names", 
	"x00101002":	"Other Patient IDs Sequence", 
	"x00101005": 	"Patient's Birth Name", 
	"x00101040":	"Patient's Address", 
	"x00101050":	"Insurance Plan Identification",
	"x00101060":	"Patient's Mother's Birth Name",
	"x00101080":	"Military Rank", 
	"x00101081":	"Branch of Service",
	"x00101090":	"Medical Record Locator",
	"x00102150":	"Country of Residence", 
	"x00102152":	"Region of Residence",
	"x00102154":	"Patient's Telephone Numbers",
	"x00102160":	"Ethnic Group",
	"x00102180":	"Occupation", 
	"x001021b0":	"Additional Patient History",
	"x001021c0":	"Pregnancy Status",
	"x001021d0":	"Last Menstrual Date",
	"x001021f0":	"Patient's Religious Preference",
	"x00102201": 	"Patient Species Description",
	"x00102202":	"Patient Species Code Sequence",
	"x00102203":	"Patient's Sex Neutered",
	"x00102293":	"Patient Breed Code Sequence",
	"x00102294":	"Breed Registration Sequence",
	"x00102295":	"Breed Registration Number",
	"x00102296":	"Breed Registry Code Sequence",
	"x00102297":	"Responsible Person",
	"x00102298":	"Responsible Person Role",
	"x00102299":	"Responsible Organization",
	"x00080080":	"Institution Name",
	"x00080081":	"Institution Address",
	"x00080082":	"Institution Code Sequence",
	"x00080090":	"Referring Physician's Name",
	"x00080092":	"Referring Physician's Address",
	"x00080094":	"Referring Physician's Telephone Numbers",
	"x00080096":	"Referring Physician Identification Sequence",
	"x00080116":	"Responsible Organization",
	"x00081048":	"Physician(s) of Record",
	"x00081049":	"Physician(s) of Record Identification Sequence",
	"x00081050":	"Performing Physician's Name",
	"x00081052":	"Performing Physician Identification Sequence",
	"x00081060":	"Name of Physician(s) Reading Study",
	"x00081062":	"Physician(s) Reading Study Identification Sequence",
	"x00081070":	"Operators' Name",
	"x00081072":	"Operator Identification Sequence",
	"x00380010":	"Admission ID",
	"x00380011":	"Issuer of Admission ID",
	"x00380016":	"Route of Admissions",
	"x0038001a":	"Scheduled Admission Date",
	"x0038001b":	"Scheduled Admission Time",
	"x0038001c":	"Scheduled Discharge Date",
	"x0038001d":	"Scheduled Discharge Time",
	"x0038001e":	"Scheduled Patient Institution Residence",
	"x00380020":	"Admitting Date",
	"x00380021":	"Admitting Time",
	"x00380030":	"Discharge Date",
	"x00380032":	"Discharge Time",
	"x00380040":	"Discharge Diagnosis Description",
	"x00380044":	"Discharge Diagnosis Code Sequence",
	"x00380300":	"Current Patient Location",
	"x00380400":	"Patient's Institution Residence",
	"x00380500":	"Patient State",
	"x00080050":	"Accession Number",
	"x0032000a":	"Study Status ID",
	"x0032000c":	"Study Priority ID",
	"x00320012":	"Study ID Issuer",
	"x00320032":	"Study Verified Date",
	"x00320033":	"Study Verified Time",
	"x00320034":	"Study Read Date",
	"x00320035":	"Study Read Time",
	"x00321000":	"Scheduled Study Start Date",
	"x00321001":	"Scheduled Study Start Time",
	"x00321010":	"Scheduled Study Stop Date",
	"x00321011":	"Scheduled Study Stop Time",
	"x00321020":	"Scheduled Study Location",
	"x00321021":	"Scheduled Study Location AE Title",
	"x00321030":	"Reason for Study",
	"x00321031":	"Requesting Physician Identification Sequence",
	"x00321032":	"Requesting Physician",
	"x00321033":	"Requesting Service",
	"x00321040":	"Study Arrival Date",
	"x00321041":	"Study Arrival Time",
	"x00321050":	"Study Completion Date",
	"x00321051":	"Study Completion Time",
	"x00321055":	"Study Component Status ID",
	"x00321060":	"Requested Procedure Description",
	"x00321064":	"Requested Procedure Code Sequence",
	"x00321070":	"Requested Contrast Agent",
	"x00324000":	"Study Comments",
	"x00402008":	"Order Entered By",
	"x00402009":	"Order Enterer's Location",
	"x00402010":	"Order Callback Phone Number",
	"x00400001":	"Scheduled Station AE Title",
	"x00400006":	"Scheduled Performing Physician's Name",
	"x0040000b":	"Scheduled Performing Physician Identification Sequence",
	"x00400010":	"Scheduled Station Name",
	"x00400011":	"Scheduled Procedure Step Location",
	"x00400012":	"Pre-Medication",
	"x00400241":	"Performed Station AE Title",
	"x00400242":	"Performed Station Name",
	"x00400243":	"Performed Location",
	"x00400296":	"Billing Item Sequence",
	"x40080042":	"Results ID Issuer",
	"x4008010c":	"Interpretation Author",
	"x40080114":	"Physician Approving Interpretation",
	"x40080119":	"Distribution Name",
	"x4008011a":	"Distribution Address",
	"x40080202":	"Interpretation ID Issuer",
	"x00080070":	"Manufacturer",
	"x00081010":	"Station Name",
	"x00081040":	"Institutional Department Name",
	"x00081090":	"Manufacturer's Model Name",
	"x00181000":	"Device Serial Number",
	"x00181016":	"Secondary Capture Device Manufacturer",
	"x00181017":	"Hardcopy Device Manufacturer",
	"x00181018":	"Secondary Capture Device Manufacturer's Model Name",
	"x00181019":	"Secondary Capture Device Software Version(s)",
	"x0018101a":	"Hardcopy Device Software Version",
	"x0018101b":	"Hardcopy Device Manufacturer's Model Name",
	"x00181020":	"Software Version(s)",
	"x00181200":	"Date of Last Calibration",
	"x00181201":	"Time of Last Calibration",
	"x0018700c":	"Date of Last Detector Calibration",
	"x0018700e":	"Time of Last Detector Calibration",
	"x00187010":	"Exposures on Detector Since Last Calibration",
	"x00187011":	"Exposures on Detector Since Manufactured"
};

var PIItagsEmptyAdd = {
	"x00101010": 	"Patient Age",
	"x00101020": 	"Patient Size",
	"x00101030": 	"PatientWeight",
	"x00102000": 	"Medical Alerts",
	"x00102110": 	"Allergies",
	"x001021a0": 	"Smoking Status",
	"x00111010": 	"Patient Status",
	"x00081030": 	"Study Description",
	"x00181030": 	"Protocol Name",
	"x00200010":    "Study ID",
	"x00080012":    "Instance Creation Date",
	"x00080013":    "Instance Creation Time",
	"x00080020":    "Study Date",
	"x00080030":    "Study Time",
	"x0008103e":    "Series Description",
	"x00080021":    "Series Date",
	"x00080031":    "Series Time",
	"x00080022":    "Acquisition Date",
	"x00080032":    "Acquisition Time",
	"x00080023":    "Content Date",
	"x00080033":    "Content Time",
	"x0008002a": 	"AcquisitionDateTime",
	"x00080034": 	"Overlay Time",
	"x00080035": 	"Curve Time"
};

var PIItagsModify = {
	"x00020012":	"",
	"x00020013":	"dicomClearPIILib",
	"x00020016":	"dicomClearPIILib",
	"x00200010":	"1"
};

var PIItagsUnique = {
	"x00020003":	"Media Storage SOP Instance UID",
	"x00080018":	"SOP Instance UID",
	"x0020000D":	"Study Instance UID",
	"x0020000E":	"Series Instance UID"
};

function makeEmptyString(length)
{
    var text = "";
    for( var i=0; i < length; i++ )
        text += " ";
    return text;
}

function pad(num, size) {
    var s = num+"";
    while (s.length < size) s = "0" + s;
    return s;
}

function clearPII(attr, vr, text){
	if(attr in PIItagsEmpty)
	{
//		console.log("clearing tag: " + attr + ": " + PIItagsEmpty[attr]);
		if( vr === 'CS' || vr === 'LO' || vr === "SH" || vr === "PN") {
            return makeEmptyString(length);
        }
        else if(vr === 'DA') {
            var now = new Date();
            return now.getYear() + 1900 + pad(now.getMonth() + 1, 2) + pad(now.getDate(), 2);
        } else if(vr === 'TM') {
            var now = new Date();
            return pad(now.getHours(), 2) + pad(now.getMinutes(), 2) + pad(now.getSeconds(), 2);
        }
		return makeEmptyString(length);
	}
	if(attr in PIItagsEmptyAdd)
	{
//		console.log("clearing tag: " + attr + ": " + PIItagsEmptyAdd[attr]);

		if( vr === 'CS' || vr === 'LO' || vr === "SH" || vr === "PN") {
            return makeEmptyString(length);
        }
        else if(vr === 'DA') {
            var now = new Date();
            return now.getYear() + 1900 + pad(now.getMonth() + 1, 2) + pad(now.getDate(), 2);
        } else if(vr === 'TM') {
            var now = new Date();
            return pad(now.getHours(), 2) + pad(now.getMinutes(), 2) + pad(now.getSeconds(), 2);
        }
		return makeEmptyString(length);
	}
//	console.log("other tag: "+attr+" = "+text);
	return text;
}

function anonymizeDICOM(file)
{
    var reader = new FileReader();
    reader.onload = function(file) {
        var arrayBuffer = reader.result;

        // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a
        // Uint8Array so we create that here
        var byteArray = new Uint8Array(arrayBuffer);

        var kb = byteArray.length / 1024;
        var mb = kb / 1024;
        var byteStr = mb > 1 ? mb.toFixed(3) + " MB" : kb.toFixed(0) + " KB";

        dataSet = dicomParser.parseDicom(byteArray);

        for(attr in dataSet.elements)
        {
            var element = dataSet.elements[attr];
            var text = "";
            var vr = element.vr;
            if(attr !== "x7fe00010" && vr !== "US" && vr !== "DS" && vr !== "UI" && vr !== "IS" && vr !== "FD" && vr !== "FL" && vr !== "UL" && vr !== "OB" && vr !== "SQ")
            {
                if(typeof element != "undefined")
                {
                    var str = dataSet.string(attr);
                    if(str !== undefined) {
                        text = str;
                    }
                }
                if(typeof dataSet.string(attr) != "undefined")
                {
                    var deIdentifiedValue = clearPII(attr, vr, text);
//                    console.log(dataSet.string(attr))
                    for(var i=0; i < element.length; i++) {
                        var char = (deIdentifiedValue.length > i) ? deIdentifiedValue.charCodeAt(i) : 32;
                        dataSet.byteArray[element.dataOffset + i] = char;
                    }
//                    console.log(dataSet.string(attr))
//                    console.log("\n")
                }
            }
        }

        file = new Blob([dataSet.byteArray], {type: "application/dicom"});
    };

    reader.fileName = file.name
    reader.readAsArrayBuffer(file);
}

function anonymizeDICOM_cb(file, callback)
{
    var reader = new FileReader();
    reader.onload = function(file) {
        var arrayBuffer = reader.result;

        // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a
        // Uint8Array so we create that here
        var byteArray = new Uint8Array(arrayBuffer);

        var kb = byteArray.length / 1024;
        var mb = kb / 1024;
        var byteStr = mb > 1 ? mb.toFixed(3) + " MB" : kb.toFixed(0) + " KB";

        dataSet = dicomParser.parseDicom(byteArray);

        for(attr in dataSet.elements)
        {
            var element = dataSet.elements[attr];
            var text = "";
            var vr = element.vr;
            if(attr !== "x7fe00010" && vr !== "US" && vr !== "DS" && vr !== "UI" && vr !== "IS" && vr !== "FD" && vr !== "FL" && vr !== "UL" && vr !== "OB" && vr !== "SQ")
            {
                if(typeof element != "undefined")
                {
                    var str = dataSet.string(attr);
                    if(str !== undefined) {
                        text = str;
                    }
                }
                if(typeof dataSet.string(attr) != "undefined")
                {
                    var deIdentifiedValue = clearPII(attr, vr, text);
//                    console.log(dataSet.string(attr))
                    for(var i=0; i < element.length; i++) {
                        var char = (deIdentifiedValue.length > i) ? deIdentifiedValue.charCodeAt(i) : 32;
                        dataSet.byteArray[element.dataOffset + i] = char;
                    }
//                    console.log(dataSet.string(attr))
//                    console.log("\n")
                }
            }
        }

        out_file = new Blob([dataSet.byteArray], {type: "application/dicom"});
        out_file.name = reader.fileName
        callback(out_file)
    };

    reader.fileName = file.name
    reader.readAsArrayBuffer(file);
}